= <span style="background-color:transparent;">keen-retry</span>  =

= A crate to help improve the resiliencyand robustness of Rust applications =

= Current as of <span style="background-color:transparent;">keen-retry</span> 0.3.0 and Rust 1.73 =

= [[Image:Image1.png|top]] =

= About the cover art =

''An illustration showing a metaphorical representation of the <tt>keen-retry</tt> Rust crate, symbolizing resilience in programming. The image features a robust, rust-colored gear, representing Rust programs, at the center. Surrounding it are several layers of shielding with a subtle pattern of binary code to signify digital protection. Bellow the gear, there's a sturdy anvil with a few sparks around it, symbolizing the process of forging and strengthening software. The gear is set against a backdrop of a stormy sky with lightning, representing challenges, but the gear remains unscathed, conveying the idea of “Rock Solid” stability. In the foreground, a translucent overlay of the <tt>keen-retry</tt> crate logo is visible, seamlessly integrated into the scene. The overall tone is powerful and confident, with a hint of technological sophistication.''

Adding to the description of the symbolism above, the hammer represents the developer, the anvil represents the foundational support of the <tt>keen-retry</tt> crate, and the gear signifies the intricate and well-crafted machinery of Rust programs that are made resilient through this crate.

The <tt>keen-retry</tt> logo, at the center of the anvil, mildly represents a labirynth: a problem that requires a fair amount of trial-and-error, emphasizing that facing some errors are not the end of the road for robust and resilient software: it is always preferable to retry as much as reasonably possible before give up with error messages and interruptions in the application’s natural flow. The logo presents a sufficiently simple labirynth, also emphasizing that the <tt>keen-retry</tt> crate takes out the complications of the complex problem of improving software resiliency while still allowing proper instrumentation.

Adding the Rust logo and the stylized Rust crab to the base symbolizes that Rust, and its community, are the primary enabler of such cool possibilities.
















= [[Image:Image2.png|top]] =

__NOTOC__
== '''Table of Contents''' ==

[[#RefHeadingToc15323947954761|Objective]]

:[[#RefHeadingToc15343947954761|Explanation of the crate's purpose]]

:[[#RefHeadingToc15363947954761|High-level overview of features]]

[[#RefHeadingToc15383947954761|Theory behind the API]]

:[[#RefHeadingToc15403947954761|Understanding Retries]]

:[[#RefHeadingToc15423947954761%20Copy%201|Two Types of Results]]

:[[#RefHeadingToc15423947954761|Functional Approach to Error Handling]]

:[[#RefHeadingToc15443947954761|Zero-Cost Abstractions]]

:[[#RefHeadingToc15463947954761|Retry Logic Composition]]

:[[#RefHeadingToc15483947954761|Backoff Strategies]]

:[[#RefHeadingToc15503947954761|Error Discrimination]]

:[[#RefHeadingToc15523947954761|Application API and Retry Chains]]

[[#RefHeadingToc15543947954761|Getting Started]]

:[[#RefHeadingToc19383947954761|Understanding the Library API]]

:[[#RefHeadingToc19403947954761|Understanding the Application API]]

:[[#RefHeadingToc19833947954761|Some Diagrams]]

[[#RefHeadingToc15563947954761|Core Concepts]]

[[#RefHeadingToc15583947954761|Use Cases]]

:[[#RefHeadingToc15603947954761|Network Operations]]

:[[#RefHeadingToc15623947954761|Resource Access]]

:[[#RefHeadingToc15643947954761|User-Level Tasks]]

:[[#RefHeadingToc15663947954761|Application Start-Up]]

:[[#RefHeadingToc15683947954761|Inter-Service Communication]]

:[[#RefHeadingToc15703947954761|Background Jobs and Workers]]

:[[#RefHeadingToc15723947954761|Custom Application API Implementations]]

:[[#RefHeadingToc15743947954761|Examples from `tests/use_cases.rs`]]

[[#RefHeadingToc15763947954761|Patterns]]

:[[#RefHeadingToc15783947954761|Pattern: Adding a keen-retry wrapper to your library]]

:[[#RefHeadingToc15803947954761|]]

:[[#RefHeadingToc15823947954761|--- How to write a `keen-retry` wrapper for your library]]

[[#RefHeadingToc15843947954761|Anti-Patterns]]

[[#RefHeadingToc15863947954761|--- Some anti-patterns:]]

[[#RefHeadingToc15883947954761|Advanced Features]]

[[#RefHeadingToc15903947954761|Instrumentation and Logging]]

[[#RefHeadingToc15923947954761|Performance Considerations]]

[[#RefHeadingToc15963947954761|Backoff]]

:[[#RefHeadingToc15983947954761|Retrying Strategies without Backoff]]

:[[#RefHeadingToc16003947954761|Retrying Strategies with Backoff]]

:[[#RefHeadingToc16023947954761|Common Backoff Algorithms and Analysis]]

::[[#RefHeadingToc16043947954761|Constant]]

::[[#RefHeadingToc16063947954761|Arithmetic Progression]]

::[[#RefHeadingToc16083947954761|Geometric Progression]]

::[[#RefHeadingToc16433947954761|The ]]

[[#RefHeadingToc15943947954761|Important Staging Rust Features]]

:[[#RefHeadingToc19423947954761|Async fn in Traits]]

:[[#RefHeadingToc19443947954761|The Try trait]]

[[#RefHeadingToc16143947954761|Index]]

= Introduction =

= The keen-retry crate first came into existence when I was working with bounded channels. One of the possible cases when channeling a message is a “buffer is full” scenario – when consumers are slower than the producers. A common pattern for channel implementations is to return the payload within the error message, encouraging the operation to be re-attempted shortly. =

= One of the first solutions was to refactor the retrying code and place it on a method specially crafted inside my application, containing this zero-copy semantics – something like “keen_sender()”. But, then, a slightly more complicated scenario arose: I’ve created two libraries that depended on one another: library A calls library B and if B fails fatably, A should also fail fatably – but they were subjected to transient errors, just like I described for the Channels. =

= Now, writing wrapper code was no longer the best thing to do: =

= The number of cases to consider grows geometrically with the number of nested (and retryable) operations. =

= When writing the application wrapper code, I felt most of the logic I was placing there belonged to the realm of the involved libraries – and not the application. =

= Creating a Retryable Result type solved these issues: the mentioned libraries were able to use it to encapsulate the knowledge of which errors were fatal and which ones could produce different outcomes if tried again. =

= The keen-retry crate was born with the following objective: “Extending Result types to foster retryability”. =

= But this was not all to the metter. Production applications need a clear view of all operations that are executed or attempted, which can become quite challenging due to the complexities of the nested retryable operations (which may, for instance, perform additional probes on a resource). To tackle this, a set of High Order Functions were added to the crate, to allow inspection and transformation of retryable operations – be them consumers, producers or procedures (that generates side effects without consuming “inputs” nor producing “outputs”). =

= This was the motivation behind the keen-retry crate: a simple, yet powerful library, focused at performance and code maintainability. It was useful to me and enabled wonderful, robust and resilient software to be built using its features. I hope it is useful to you as well. =

= Throughout this book, we will focus on hypothetical operations revolving around a client/server, with connect, send and receive operations, akin to a procedure, a consumer and a producer – which is one of the key concepts that put keen-retry apart from other similar crates. =

= At the end, a visit to “Other Crates Similar to keen-retry” is performed on its own section, so you can better judge if keen-retry is the right choice for your case. =

= {{anchor|RefHeadingToc15323947954761}} A Dive Into The Problem =

== {{anchor|RefHeadingToc15343947954761}} Explanation of the crate's purpose ==

<div style="text-align:center;">The <tt>keen-retry</tt> crate provides a robust framework for Rust applications to handle and recover from transient errors more effectively. It equips developers with the tools to transform standard operations into retryable workflows with a focus on performance and code clarity. </div>

The crate distinguishes between two kinds of “Results”: one for outcomes that are not “final” (for which repeating the operation may fix the transient issue) and the other for final results, after passing through any retrying process.

The crate also offers a “Library API” and an “Application API”:* '''Library API''': designed to be used by libraries that want to incorporate error handling & recovery (or “retrying”, for short) into their features. By wrapping your library or API with <tt>keen-retry</tt>, operations can be made retryable with minimal overhead and maximum expressiveness.
* '''Application API''': designed to be exposed down to the application level, providing a functional API to allow deep control of the handling and recovery of errors, leveraging zero-copy and advanced instrumentation. This is foundational to the chaining of retryable operations, allowing developers to create complex, resilient workflows that gracefully handle transient failures in simple or complex scenarios.



== {{anchor|RefHeadingToc15363947954761}} High-level overview of features ==

* '''Retryable Result''': The “Library API” consists, primarily, of the type <tt>RetryResult</tt>, which enhances the standard Rust <tt>Result</tt> type by introducing a third variant: <tt>Transient</tt> (in addition to <tt>Result::Ok</tt> and <tt>Result::Err</tt>). Special care was taken, throughout the crate, to leverage zero-copy – this is particularly useful for consumers that may experience transient failures. See the “Patterns” section for more details.
* '''Functional Application API''': A set of High Order Functions designed for use by the application logic, enabling detailed instrumentation and zero-copy. On the other hand, applications are free to not opt-in for retries: a <tt>RetryResult</tt> may be easily converted to a standard <tt>Result</tt> if the retrying features are not desired.
* '''Zero-Cost Abstractions''': If an operation succeeds or fails fatally on the initial attempt, no extra code is executed, ensuring the usual efficiency. See the “Performance” section for more details.
* '''Distinct Operations for Initial and Subsequent Attempts''': The library allows different handling for the initial attempt and retries, providing flexibility for detailed error reporting and nested retry logic – for instance, a network <tt>send()</tt> might fail because the connection was dropped: the retry operation could spend some time verifying the connection and even reconnecting. See the <tt>tests/use_cases.rs</tt> integration test for a thorough example.
* '''Sync and Async Support''': Full support for both synchronous and asynchronous operations, allowing it to fit seamlessly into various types of Rust applications. <tt>Features</tt> are available for turning off Tokio / async support and all related dependencies.
* '''Backoff Strategies''': Configurable backoff strategies to prevent resource exhaustion during retries are available. For a thorough overview, please refer to the “Backoff” section.
* '''Comprehensive “Final” Result Types''': <tt>ResolvedResult</tt> encapsulate all possible outcomes of retryable operations, through which advanced instrumentation can be added.
* '''Ease of Integration''': The library is designed to integrate smoothly with existing Rust codebases, requiring minimal changes to adopt retry capabilities.



<div style="text-align:center;">This comprehensive suite of features is crafted to provide a scalable and expressive error handling and recovery solution that fits naturally within the Rust ecosystem.</div>

= {{anchor|RefHeadingToc15383947954761}} Theory behind the API =

At the heart of the <tt>keen-retry</tt> crate is the concept of resilience in software systems. Resilience, in this context, refers to the system's ability to handle and recover from failures gracefully. This is particularly important in distributed systems where network hiccups, transient service unavailability, or temporary resource constraints are common. The <tt>keen-retry</tt> library provides a structured way to approach these challenges by enabling operations to be retried under predefined conditions.

== {{anchor|RefHeadingToc15403947954761}} Understanding Retries ==

Retry patterns allow applications to automatically repeat an operation in the face of failure, giving the system a chance to recover, if the temporary underlying issue is resolved, before a fatal error is finally computed. However, not all failures should trigger a retry. The <tt>keen-retry</tt> crate distinguishes between transient failures that are potentially recoverable and permanent failures that are not, allowing developers to define nuanced retry policies.

== {{anchor|RefHeadingToc15423947954761 Copy 1}} Two Types of Results ==

Operations are expected to succeed on the first attempt, having their outputs extracted and their inputs consumed. When they don’t, a first “Result” is obtained – we call it <tt>RetryResult</tt>: this type distinguishes between three states: <tt>Ok</tt>, <tt>Transient</tt> and <tt>Fatal</tt>.

<tt>Ok</tt> and <tt>Fatal</tt> are terminal states – they are ready to be converted back to a standard Rust <tt>Result</tt> type. The <tt>Transient</tt> state allows triggering a set of additional steps to attempt recovery.

When the retrying process takes place, the second “Result” – <tt>ResolvedResult</tt>, plays a role: it is considered a “Final” Result, as no more retries can be performed. This type can also be converted to a standard <tt>Result</tt> type, although it contains more nuanced states in case the application wants to inspect it: <tt>Ok</tt>, <tt>Fatal</tt>, <tt>Recovered</tt>, <tt>GivenUp</tt> and <tt>Unrecoverable</tt>. For more more details, please consult the [https://docs.rs/keen-retry/0.2.2/keen_retry/enum.ResolvedResult.html library’s documentation].

== {{anchor|RefHeadingToc15423947954761}} Functional Approach to Error Handling ==

<tt>keen-retry</tt> adopts a functional paradigm akin to Rust’s own <tt>Result<></tt> and <tt>Option<></tt> types, ensuring a familiar and idiomatic experience for Rust developers. This design choice facilitates clean and maintainable code, avoiding common pitfalls such as "callback hell" that can arise with more imperative error-handling strategies.

A set of High Order Functions are provided to manipulate both the <tt>RetryResult</tt> and the <tt>ResolvedResult</tt> types, allowing detailed instrumentation to be incorporated in all phases of the error handling and recovery process.

== {{anchor|RefHeadingToc15443947954761}} Zero-Cost Abstractions ==

<tt>keen-retry</tt>-enabled methods, that you expose in your own API or library, are first class citizens: the <tt>keen-retry</tt> “final” result type <tt>ResolvedResult</tt> may be easily converted to an ordinary <tt>Result</tt>, so you don’t need to distinguish your “original operations” from the “<tt>keen-retry</tt>-enabled ones” – and the conversion is done at compile time:

<span style="color:#5f826b;">''/// </span><span style="color:#5f826b;">In the example bellow, </span><span style="color:#68a67e;">`YourLibrary`</span><span style="color:#5f826b;"> uses the </span><span style="color:#68a67e;">`keen-retry`</span><span style="color:#5f826b;"> API''</span>

<span style="color:#5f826b;">''/// </span><span style="color:#5f826b;">and</span><span style="color:#5f826b;"> we may, </span><span style="color:#5f826b;">simply</span><span style="color:#5f826b;">, </span><span style="color:#5f826b;">not opt-in for</span><span style="color:#5f826b;"> any retrying features</span><span style="color:#5f826b;">/// -- it will behave like </span><span style="color:#5f826b;">a standard </span><span style="color:#68a67e;">`Result<</span><span style="color:#68a67e;">O, E</span><span style="color:#68a67e;">>`''</span><span style="color:#cf8e6d;">fn </span><span style="color:#56a8f5;">do_something</span><span style="color:#bcbec4;">() -> Result<(), StdErrorType> { </span><span style="color:#cf8e6d;">let </span><span style="color:#bcbec4;">handle</span><span style="color:#bcbec4;"> = </span><span style="color:#bcbec4;">YourLibrary</span><span style="color:#bcbec4;">::</span><span style="color:#57aaf7;">''new''</span><span style="color:#bcbec4;">(</span><span style="color:#2aacb8;">...</span><span style="color:#bcbec4;">); </span><span style="color:#bcbec4;">handle</span><span style="color:#bcbec4;">.</span><span style="color:#bcbec4;">retryable_method</span><span style="color:#bcbec4;">().</span><span style="color:#bcbec4;">into</span><span style="color:#bcbec4;">_result</span><span style="color:#bcbec4;">()</span><span style="color:#cf8e6d;">?</span><span style="color:#bcbec4;"><nowiki>;</nowiki> </span><span style="color:#c77dbb;">''Ok''</span><span style="color:#bcbec4;">(())}</span>


In the example above, not using the <tt>keen-retry</tt> result features works as treating both permanent and transient errors as hard failures – no retrying measures will be taken and <tt>Err</tt> will be propagated.

This simplifies your API design by not requiring the distinction of original / <tt>keen-retry</tt>-enabled methods: simply enable your methods to return a <tt>RetryResult</tt> and user code will require only a minor change. Nonetheless, this is not the recommended pattern: it is recommended that Libraries and APIs do create additional methods with the suffix “_retry()”: those are the ones that should return a <tt>RetryResult</tt>. Please consult the “Patterns” section for more details.

== {{anchor|RefHeadingToc15463947954761}} Retry Logic Composition ==

A key feature of the <tt>keen-retry</tt> crate is its support for composing complex retry logic through chaining. This composability is crucial for building robust systems where operations depend on multiple, potentially flaky, services or resources. By allowing operations to be chained, <tt>keen-retry</tt> makes it possible to articulate clear and maintainable error recovery flows.

Bellow, you will see code that chains the retrying up to a reconnection, if sending a message fails:

<span style="color:#cf8e6d;">self</span><span style="color:#bcbec4;">.send(payload) .retry_with_async(|</span><span style="color:#bcbec4;">payload</span><span style="color:#bcbec4;">| </span><span style="color:#cf8e6d;">async move </span><span style="color:#bcbec4;">{ </span><span style="color:#cf8e6d;">if </span><span style="color:#bcbec4;">!</span><span style="color:#cf8e6d;">self</span><span style="color:#bcbec4;">.is_connected() { </span><span style="color:#cf8e6d;">if let </span><span style="color:#bcbec4;">Err(err)</span><span style="color:#cf8e6d;"> = </span><span style="color:#cf8e6d;">self</span><span style="color:#bcbec4;">.connect_to_server().</span><span style="color:#cf8e6d;">await</span><span style="color:#bcbec4;"> { </span><span style="color:#cf8e6d;">return </span><span style="color:#bcbec4;">RetryConsumerResult::Fatal { input: payload, error: TransportErrors::CannotReconnect {root_cause: err.into()} }; } } </span><span style="color:#cf8e6d;">self</span><span style="color:#bcbec4;">.send(payload) })</span><span style="color:#7a7e85;"> </span><span style="color:#bcbec4;">.with_exponential_jitter</span><span style="color:#bcbec4;">(</span><span style="color:#2aacb8;"><tt>''...''</tt></span><span style="color:#bcbec4;">)</span><span style="color:#bcbec4;"> .await</span>


Notice that <tt>connect_to_server()</tt> may perform its own retrying process – which may lead to highly delayed retrying procedures if nesting is not done properly. Please refer to the “Anti-Patterns” section for more details regarding this phenomenon and how to enforce time-outs.

== {{anchor|RefHeadingToc15483947954761}} Backoff Strategies ==

Implementing retries without a strategy can lead to exacerbated problems, like overwhelming a struggling service with a flood of retries. <tt>keen-retry</tt> provides configurable backoff algorithms that can be employed to intelligently space out retry attempts, giving systems the breathing room needed to recover.

== {{anchor|RefHeadingToc15503947954761}} Error Discrimination ==

The <tt>keen-retry</tt> API enables operations to signal whether a failure is transient or fatal. This distinction is crucial for avoiding unnecessary retries in situations where they would be futile, such as with authentication failures or other permanent issues.

This requires that Libraries are able to distinguish between these classes of errors. So, before the integration effort, maybe refactorings have to be made.

== {{anchor|RefHeadingToc15523947954761}} Application API and Retry Chains ==

The key feature of <tt>keen-retry</tt> is its Application API, that empowers developers to implement retry logic at the application level. This extends the resilience capabilities all the way from low-level libraries to the final user-facing applications, creating a cohesive retry mechanism throughout the stack.


= {{anchor|RefHeadingToc15543947954761}} Getting Started =

This is the birds-eye-view of how to work with the <tt>keen-retry</tt> crate:

[[Image:Object1.png|middle]]

Please notice the following from the above diagram:* <tt>lib_method_retry()</tt> is a method inside your library, enabling the <tt>keen-retry</tt> capabilities to your users by returning a <tt>RetryResult</tt>.
* <tt>RetryResult</tt> enhances the kinds of <tt>Result<></tt> your library reports: they may be <tt>Ok</tt>, <tt>Transient</tt> and <tt>Fatal</tt> – enabling the distinction of the two nature of errors.
* On the application, developers have the choice to opt-in to the <tt>keen-retry</tt> features. Opting-out is as easy as calling <tt>.into_result()</tt>. Otherwise, call <tt>.retry_with()</tt> and one of the backoff strategies to get a <tt>ResolvedResult</tt>, which, then, may be converted back to a standard <tt>Result<></tt>.



This birds-eye-view is enough to fully expose the “Retry Features” of the library. Looking in more details reveal another aspect: instrumentation.* The <tt>RetryResult</tt> type may be used to log successes on the first attempt, fatal failures on the first attempt and transient failures that will be subjected to retrying. Apart from the inspections, High Order Functions are available to enable, for instance, measuring the time spent in retrying – which is done by enriching the “input” with time measurements data. Please refer to the “Patterns” section for more details.
* The closure ingested by <tt>.retry_with()</tt> typically recalls the operation. This is the point where nested retryable operations may be invoked to make the transient failure go away. Additional instrumentation may be added here as well.
* Once the retrying process is over, a <tt>ResolvedResult</tt> is generated. With this object, the application may log additional information as the number of retries performed, the errors encountered, and, if you have enriched the input with time measurements, you may also log the time lost in the retrying process.



== {{anchor|RefHeadingToc19383947954761}} Understanding the Library API ==

Throughout 


== {{anchor|RefHeadingToc19403947954761}} Understanding the Application API ==

…






= {{anchor|RefHeadingToc15563947954761}} Core Concepts =

<tt><<here I should introduce how the library works>>keen-retry</tt> introduces several key abstractions:* <tt>RetryConsumerResult</tt>, <tt>ProducerRetryResult</tt>, <tt>RetryResult</tt> serve as wrappers around retryable operations, similar to <tt>Result<></tt>.
* <tt>KeenRetry[Async]Executor</tt> is responsible for executing the retry logic according to the selected backoff algorithm and retry limits.
* <tt>ResolvedResult</tt> provides a comprehensive result type encompassing all possible outcomes of a retry operation.



= {{anchor|RefHeadingToc15583947954761}} Use Cases =

The <tt>keen-retry</tt> crate is versatile, finding its place in a wide array of scenarios where operations may fail due to transient issues. Here are several use cases that exemplify how the library can be employed:

== {{anchor|RefHeadingToc15603947954761}} Network Operations ==

In the realm of network requests – such as API calls, database transactions, or remote service interactions – failures can occur due to temporary network instability or service unavailability. <tt>keen-retry</tt> can wrap these operations, allowing them to be retried with a strategy appropriate for the context, whether it be immediate, delayed, exponential backoff, or a custom approach.

== {{anchor|RefHeadingToc15623947954761}} Resource Access ==

Operations involving file systems or other resources can intermittently fail due to locks, contention, or resource limitations. Employing <tt>keen-retry</tt> enables developers to smoothly handle these scenarios, improving user experience and system reliability.

== {{anchor|RefHeadingToc15643947954761}} User-Level Tasks ==

Tasks initiated by end-users that are prone to failure, such as uploading files to a server or posting data to a web service, can benefit from <tt>keen-retry</tt>. By integrating retry logic, applications can reduce the need for manual retry attempts by users, thereby enhancing the overall usability.

== {{anchor|RefHeadingToc15663947954761}} Application Start-Up ==

During the start-up phase of applications, especially those that rely on external services or databases, <tt>keen-retry</tt> can ensure that initial connections are established reliably, even in the face of transient service delays or unavailability.

== {{anchor|RefHeadingToc15683947954761}} Inter-Service Communication ==

In microservices architectures, services often need to communicate with each other. Given the distributed nature of such systems, <tt>keen-retry</tt> is invaluable for managing the inherent instability and ensuring that communication between services is resilient.

== {{anchor|RefHeadingToc15703947954761}} Background Jobs and Workers ==

For background processing systems, workers may encounter temporary issues while handling jobs. <tt>keen-retry</tt> can be used to automatically retry failed jobs according to specified policies, thereby reducing the need for manual intervention and monitoring.

== {{anchor|RefHeadingToc15723947954761}} Custom Application API Implementations ==

<tt>keen-retry</tt>'s Application API allows library consumers to define their own retry logic, tailored to the specific requirements of their application. This ensures that the retry mechanisms are as fine-grained and context-specific as necessary.

== {{anchor|RefHeadingToc15743947954761}} Examples from `tests/use_cases.rs` ==

The `<tt>tests/use_cases.rs</tt>` file provides concrete examples of these scenarios. It showcases the <tt>keen-retry</tt> crate in action, demonstrating how to handle both synchronous and asynchronous operations, incorporate detailed instrumentation, and define complex retry policies. These examples are instrumental in illustrating the practical application of the library's features.


= {{anchor|RefHeadingToc15763947954761}} Patterns =

As general guidelines, when using <tt>keen-retry</tt>, it is recommended to:

For Libraries:* Define clear conditions for when an operation should be retried and when it should fail immediately. Usually this is done by having custom error types and placing this knowledge along with them, in a <tt>.is_fatal()</tt> method.
* If you own the library, additional methods should be added to the API: <tt><nowiki>*_retry()</nowiki></tt>. These methods should map all the original methods suitable for retrying and return a <tt>RetryResult</tt>.
* If you don’t own the library, these same methods may be added on an adapter type.





Having the *_retry() methods available in the libraries are advantageous, as other libraries may use these methods for an easy determination of the transient failures.


For Applications:* Define the retry algorithm – possibly, by just calling the same operation again or by chaining retryable operations for complex workflows with enhanced resiliency.
* Consider one of the backoff strategies to avoid overwhelming resources.
* Use the High Order Functions to create rich, informative and meaningful instrumentation.



Bellow follow the details of the established patterns that promote resiliency and clarity.

== {{anchor|RefHeadingToc15783947954761}} Pattern: Adding a keen-retry wrapper to your library ==

For libraries and for the operations you want to add retrying features to, wrap them with a method that converts the standard Rust’s error handling to ours:

<span style="color:#5f826b;"><tt>''/// Assume </tt></span><span style="color:#68a67e;">`</span><span style="color:#68a67e;">produce</span><span style="color:#68a67e;">_operation`</span><span style="color:#5f826b;"> is a user-defined function that returns a </span><span style="color:#68a67e;">`Result`</span><span style="color:#5f826b;">.''</span><span style="color:#cf8e6d;">fn </span><span style="color:#56a8f5;">produce</span><span style="color:#56a8f5;">_operation_retryable</span><span style="color:#bcbec4;">() -> </span><span style="color:#bcbec4;">'''RetryProducerResult'''</span><span style="color:#bcbec4;"><OutputType, ErrorType> { </span><span style="color:#cf8e6d;">match </span><span style="color:#bcbec4;">produce_</span><span style="color:#bcbec4;">operation() { </span><span style="color:#c77dbb;">''Ok''</span><span style="color:#bcbec4;">(output) => </span><span style="color:#bcbec4;">'''RetryResult::</span><span style="color:#c77dbb;">''Ok'''''</span><span style="color:#bcbec4;">(output), </span><span style="color:#c77dbb;">''Err''</span><span style="color:#bcbec4;">(e) => </span><span style="color:#cf8e6d;">match </span><span style="color:#bcbec4;">e { ErrorType::Transient(_) => </span><span style="color:#bcbec4;">'''RetryResult::</span><span style="color:#c77dbb;">''Retry'''''</span><span style="color:#bcbec4;">(e), _ => </span><span style="color:#bcbec4;">'''RetryResult::</span><span style="color:#c77dbb;">''Fatal'''''</span><span style="color:#bcbec4;">(e), }, }}</span>


This pattern shows how to convert a standard <tt>Result</tt> into one of the <tt>RetryResult</tt> types, differentiating between transient and fatal errors.

As seen, zero-cost abstractions guarantees we can use <tt>produce_operation_retryable()</tt> as if it returned the standard <tt>Result</tt> type: this gives us the possibility to simply name this method <tt>produce_operation()</tt>.

Notice the following <tt>keen-retry</tt> error types exist to leverage zero-copy:* <tt>RetryConsumerResult</tt>: use this for operations that require expensive input data – for instance, adding a message to a queue collecting the “processing results”: in this case, retrying (in case adding to the queue fails) would be done by reusing the input;
* <tt>RetryProducerResult</tt>: use this for operations use resources to produce an output;
* <tt>RetryResult</tt>: this is the general type, encapsulating both input, output and the error type



== {{anchor|RefHeadingToc15803947954761}} Pattern: Backoff Strategy Configuration ==

<div style="text-align:center;">After writing a <tt>keen-retry</tt> wrapper for your API, you may configure a simple retry & backoff strategy that defines the delay between retries and the maximum number of re-attempts:</div>

<span style="color:#7a7e85;"><tt>// Use an exponential backoff strategy for retries.</tt></span><span style="color:#cf8e6d;">let </span><span style="color:#bcbec4;">result = produce_operation_retryable() </span><span style="color:#bcbec4;">'''.retry_with'''</span><span style="color:#bcbec4;">(|_| produce_operation_retryable()) </span><span style="color:#7a7e85;">// </span><span style="color:#7a7e85;">backoff exponentially, from 100ms to 15 seconds in 20 re-attempts // with +/- 10% random variance – </span><span style="color:#7a7e85;">ideal for retrying network requests</span><span style="color:#7a7e85;"> </span><span style="color:#bcbec4;">'''.with_exponential_jitter'''</span><span style="color:#bcbec4;">(</span><span style="color:#2aacb8;">1</span><span style="color:#2aacb8;">00</span><span style="color:#bcbec4;">..=</span><span style="color:#2aacb8;"><tt>''15000''</tt></span><span style="color:#bcbec4;">, </span><span style="color:#2aacb8;"><tt>''20''</tt></span><span style="color:#bcbec4;">, </span><span style="color:#2aacb8;"><tt>''0.1''</tt></span><span style="color:#bcbec4;">)</span><span style="color:#bcbec4;"> .into();</span>


Here, an exponential backoff strategy is applied in 20 steps, where each sleeping duration is subjected to a random variation of 10%.

Please refer to the appendix “Common Backoff Algorithms and Analysis” for additional information on common strategies and other usage scenarios.




== {{anchor|RefHeadingToc15823947954761}} --- How to write a `keen-retry` wrapper for your library ==

--- How to add a `keen-retry` layer for a third-party library

--- How to write meaningful instrumentation for retry operations

-- Write tests that asserts on the number of retries actually done. Preferably, don’t put counters only in tests, but in the application, where applicable, so these statistics are more visible.

<div style="text-align:center;">-- Use the powerful “composable retry policies”</div>

<div style="text-align:center;">-- Choose carefully the appropriate backoff strategy</div>

<div style="text-align:center;"><tt>keen-retry</tt> supports custom backoff strategies, which may be easily expressed through iterators – be it with fixed or randon delays, or even with arithmetic or geometric progressions. Choosing the right strategy helps in avoiding resource contention and giving dependent services time to recover.</div>

= {{anchor|RefHeadingToc15843947954761}} Anti-Patterns =

The general recommendations are to always avoid:* Retrying operations that fail due to non-transient errors.
* Infinite retry loops without backoff strategies, which can lead to resource exhaustion.
* Overly complex retry policies that make the code difficult to understand and maintain.



= {{anchor|RefHeadingToc15863947954761}} --- Some anti-patterns: =

<div style="text-align:center;margin-left:0cm;margin-right:0cm;">-- When enabling `keen-retry` in your library:</div>

<div style="text-align:center;margin-left:0cm;margin-right:0cm;">1) Implement a `keen-retry` wrapper for your library’s API but not writing integration tests to assure they work as intended.</div>

<div style="text-align:center;margin-left:0cm;margin-right:0cm;">2) Not distinguishing among transient and permanent errors</div>


<div style="text-align:center;margin-left:0cm;margin-right:0cm;">-- When using a library that has a `keen-retry` wrapper</div>

<div style="text-align:center;margin-left:0cm;margin-right:0cm;">3) Using a library that has a `keen-retry` wrapper around retryable operations but not writing unit tests to prove they perform the retries & instrumentation as intended.</div>


<div style="text-align:center;margin-left:0cm;margin-right:0cm;">-- General</div>

<div style="text-align:center;margin-left:0cm;margin-right:0cm;">4) Avoiding Retry Storms</div>

<div style="text-align:center;margin-left:0cm;margin-right:0cm;">In distributed systems, synchronizing retries can lead to 'retry storms' where many clients retry simultaneously, overwhelming the system. Use <tt>keen-retry</tt>'s features to randomize retry intervals and spread out the load.</div>

<div style="text-align:center;">5) Not adding instrumentation to retries</div>

<div style="text-align:center;">Retrying may have the downside, when bugs happen, of causing too much extra / unnecessary work to be going on silently. Instrumenting the retries is key to detect any logic misbehaviors as soon as possible – preferably, before reaching production. When writing tests, use counters on the number of retries and assert on them.</div>

6) Nesting without Timeouts

Nested retry operations may scale exponentially, regarding the time they take to exhaust all nested backoffed retries. For this reason, it is always advisable to use “Timeouts” when nested retries are in place.

= {{anchor|RefHeadingToc15883947954761}} Advanced Features =

Discuss the nuances of using <tt>keen-retry</tt> with both synchronous and asynchronous operations, and how to handle nested retries for operations that depend on other retryable operations.

= {{anchor|RefHeadingToc15903947954761}} Instrumentation and Logging =

<tt>keen-retry</tt> offers features for detailed instrumentation, allowing developers to log retry attempts, errors, and successes in a structured manner. The <tt>ResolvedResult</tt> type provides facilities for building succinct reports of retry attempts.

= {{anchor|RefHeadingToc15923947954761}} Performance Considerations =

Discuss the zero-cost abstractions provided by <tt>keen-retry</tt>, which ensure that if an operation succeeds or fails fatally on the first attempt, no additional overhead is incurred.

= {{anchor|RefHeadingToc15963947954761}} Backoff =

Backoff refers to the practice of deliberately delaying retries after encountering failures. This delay serves several important purposes:# '''Prevents Overloading Systems:''' By introducing a delay between retries, programs avoid overwhelming overloaded systems with repeated requests. This allows the system to recover and handle the requests more effectively.
# '''Reduces Contention:''' Back off helps reduce contention for resources, especially when multiple programs or services are attempting to access the same resource simultaneously. This can prevent congestion and improve overall performance.
# '''Prevents Thrashing:''' Thrashing occurs when a system spends more time retrying failed operations than performing useful work. Back off helps prevent thrashing by slowing down the retry process and giving the system time to recover.
# '''Reduces Error Rates:''' By delaying retries, programs can avoid repeating the same mistakes that caused the original failures. This can lead to lower error rates, fewer log warnings and more reliable operation.



For these reasons, retrying with a backoff is an essential component of resilient programming, enabling programs to handle transient failures gracefully and maintain overall system stability and performance.

== {{anchor|RefHeadingToc15983947954761}} Retrying Strategies without Backoff ==

Nonetheless, there are a few cases where not using a backoff is advantageous:* Hard real-time systems, with local communications and low error rates. An example of this may be a single producer trying to put elements on a local queue (with multiple consumers). If the queue gets full, it may be acceptable for the producer to spin during retries, instead of sleeping.
* Services that may recover from transient errors faster than the time it takes to prepare a new retry attempt. The <tt>keen-retry</tt> library allows custom code to run on each retry attempt – which may, for instance, log the occurrence, compute a metric or do any other long operation, such as storing something in a database. Should these pre-retry operations take too long, backing off might just not be needed at all.



To account for these scenarios, the following methods are provided:* <tt>spinning_forever()</tt>: keeps the thread busy retrying, without context-switching, but putting the CPU in the “relaxed” state, suitable for spin loops that reacts the a very low latency. Use with caution, as this method may dead-lock the thread, at 100% CPU usage, as there is no limit for the number of retries:<br/><div style="margin-left:0.5in;margin-right:0in;"><span style="color:#cf8e6d;">let </span><span style="color:#bcbec4;">result = produce_operation_retryable()</span><span style="color:#bcbec4;"> .retry_with</span><span style="color:#bcbec4;">(|_| produce_operation_retryable()) </span><span style="color:#7a7e85;">// spin-loops until success </span><span style="color:#bcbec4;">'''.spinning_forever'''</span><span style="color:#bcbec4;">() .into();</span></div>
* <tt>spinning_until_timeout(duration, timeout_error)</tt>: also keeps the thread busy retrying, possibly context-switching to consult the system time – but limits the locking to the specified timeout <tt>duration</tt>, which, if elapsed, causes the operation to fail with <tt>timeout_error</tt>:<br/><div style="margin-left:0.5in;margin-right:0in;"><span style="color:#cf8e6d;">let </span><span style="color:#bcbec4;">result = produce_operation_retryable()</span><span style="color:#bcbec4;"> .retry_with</span><span style="color:#bcbec4;">(|_| produce_operation_retryable()) </span><span style="color:#7a7e85;">// spin-loops </span><span style="color:#7a7e85;">for up to the given timeout</span><span style="color:#7a7e85;"> </span><span style="color:#bcbec4;">'''.spinning_until_timeout'''</span><span style="color:#bcbec4;">(1000ms, TimeoutError) .into();</span></div>



For <tt>async</tt> programming, there are additional methods available:* <tt>yielding_forever()</tt>: similar to <tt>spinning_forever()</tt> above, but let Tokio execute other tasks instead of simply looping:<br/><div style="margin-left:0.5in;margin-right:0in;"><span style="color:#cf8e6d;">let </span><span style="color:#bcbec4;">result = produce_operation_retryable()</span><span style="color:#bcbec4;"> .retry_with</span><span style="color:#bcbec4;">(|_| produce_operation_retryable()) </span><span style="color:#7a7e85;">// </span><span style="color:#7a7e85;">let </span><span style="color:#7a7e85;">T</span><span style="color:#7a7e85;">okio run other tasks</span><span style="color:#7a7e85;"> until success </span><span style="color:#bcbec4;">'''.yielding_forever'''</span><span style="color:#bcbec4;">() .into();</span></div>
* <tt>yielding_until_timeout(duration, timeout_error)</tt>: similar to <tt>spinning_until_timeout()</tt> above, but let Tokio execute other tasks instead of simply looping:<br/><div style="margin-left:0.5in;margin-right:0in;"><span style="color:#cf8e6d;">let </span><span style="color:#bcbec4;">result = produce_operation_retryable()</span><span style="color:#bcbec4;"> .retry_with</span><span style="color:#bcbec4;">(|_| produce_operation_retryable()) </span><span style="color:#7a7e85;">// </span><span style="color:#7a7e85;">let Tokio run other tasks</span><span style="color:#7a7e85;"> </span><span style="color:#7a7e85;">for up to the given timeout</span><span style="color:#7a7e85;"> </span><span style="color:#bcbec4;">'''.yielding_until_timeout'''</span><span style="color:#bcbec4;">(1000ms, TimeoutError) .into();</span></div>



== {{anchor|RefHeadingToc16003947954761}} Retrying Strategies with Backoff ==

For all other usage scenarios, a backoff strategy is recommended.

Bellow we will see some common strategies, going from the simplest to the more sophisticated ones.

== {{anchor|RefHeadingToc16023947954761}} Common Backoff Algorithms and Analysis ==

<div style="text-align:center;margin-left:0cm;margin-right:0cm;">As seen, the <tt>keen-retry</tt> crate offers flexible backoff configurations through iterators, which specify both the amount of sleeping time between attempts as well as the number of attempts. Although the users may build their own strategies, here goes a summary & analysis of the most common ones:</div>

=== {{anchor|RefHeadingToc16043947954761}} Constant ===

<div style="text-align:center;margin-left:0cm;margin-right:0cm;">This is the simplest backoff possible: simply sleep for <tt>''s''</tt> on each of the <tt>''n''</tt> attempts:</div>

<span style="color:#bcbec4;">.with_delays((</span><span style="color:#2aacb8;">1</span><span style="color:#bcbec4;">..=</span><span style="color:#2aacb8;"><tt>'''''n'''''</tt></span><span style="color:#bcbec4;">).map(|</span><span style="color:#bcbec4;">_</span><span style="color:#bcbec4;">| Duration::</span><span style="color:#57aaf7;">''from_millis''</span><span style="color:#bcbec4;">(</span><span style="color:#bcbec4;"><tt>'''''s'''''</tt></span><span style="color:#bcbec4;">)</span><span style="color:#bcbec4;">)</span>


<div style="text-align:center;margin-left:0cm;margin-right:0cm;">The total time spent sleeping between re-attempts is a simple multiplication:</div>

<div style="text-align:center;"><math>\sum =n\ast s</math></div>


Although simple, you must be careful when choosing this strategy, as the number of simultaneous attempts quicky scale up with the number of instances running, which may be of concern if the operation make requests to external services: overloading the resource becomes a possibility. For this reason, for large <tt>''n''</tt>, this strategy may only be acceptable if, at most, a few instances are running simultaneously – lets say, on a scheduled job.

On the “pros” side, this strategy offers a very predicable backoff sleeping time, which may be desired for some workloads.

=== {{anchor|RefHeadingToc16063947954761}} Arithmetic Progression ===

<div style="text-align:center;margin-left:0cm;margin-right:0cm;">This is also a simple backoff strategy, but goes an extra mile in avoiding the overload of external services by varying the sleeping time between re-attempts progressively:</div>

<span style="color:#bcbec4;">.with_delays((</span><span style="color:#2aacb8;">1</span><span style="color:#2aacb8;">00</span><span style="color:#bcbec4;">..=</span><span style="color:#2aacb8;">1</span><span style="color:#2aacb8;">000</span><span style="color:#bcbec4;">).</span><span style="color:#bcbec4;">step_by(</span><span style="color:#2aacb8;">100</span><span style="color:#bcbec4;">).</span><span style="color:#bcbec4;">map(|millis| Duration::</span><span style="color:#57aaf7;">''from_millis''</span><span style="color:#bcbec4;">(millis)))</span>


<div style="text-align:center;margin-left:0cm;margin-right:0cm;">In the above expression, the number of re-attempts, <tt>''n''</tt>, is not directly expressed – but it may be determined through the the initial element <tt>''a<sub>1''</tt></sub>, the last element <tt>''a<sub>n''</tt></sub>, and the step <tt>''s''</tt> between elements with:</div>

<div style="text-align:center;margin-left:0cm;margin-right:0cm;"><math>n=1+\frac{{a}_{n}-{a}_{1}}{s}</math></div>


<div style="text-align:center;">With that, the maximum time spent sleeping between re-attempts is given by sum of the arithmetic progression, through the formula:</div>

<div style="text-align:center;"><math>\sum =\frac{n}{2}\times \left({a}_{1}+{a}_{n}\right)</math></div>

<div style="text-align:center;margin-left:0cm;margin-right:0cm;">Where:</div>* <div style="margin-left:0in;margin-right:0in;"><tt>'''''n'''''</tt> is the number of terms in the progression,</div>
* <div style="margin-left:0in;margin-right:0in;"><tt>'''''a<sub>1'''''</tt></sub> is the first term,</div>
* <div style="margin-left:0in;margin-right:0in;"><tt>'''''a<sub>n'''''</tt></sub> is the last term.</div>



<div style="text-align:center;margin-left:0cm;margin-right:0cm;"></div>

=== {{anchor|RefHeadingToc16083947954761}} Geometric Progression ===

This strategy is a step towards preserving resources, increasing exponentially the backoff time with a given ratio:

<span style="color:#bcbec4;">.with_delays</span><span style="color:#bcbec4;">((</span><span style="color:#2aacb8;">1</span><span style="color:#bcbec4;">..</span><span style="color:#bcbec4;"><nowiki>=</nowiki></span><span style="color:#2aacb8;">1</span><span style="color:#2aacb8;">5</span><span style="color:#bcbec4;">).map(|</span><span style="color:#bcbec4;">i</span><span style="color:#bcbec4;">| Duration::from_millis(</span><span style="color:#2aacb8;">1</span><span style="color:#bcbec4;">.</span><span style="color:#2aacb8;">5849f64</span><span style="color:#bcbec4;">.powi(</span><span style="color:#bcbec4;">i</span><span style="color:#bcbec4;">))))</span>


In this example, up to 15 retries are performed. Considering the retry attempts fail immediately, the total delay may be calculated with the formula for the sum of a geometric progression:

<div style="text-align:center;"><math>\sum =\frac{{a}_{1}\left(1-{r}^{n}\right)}{1-r}</math></div>

which, on our case, may be simplified to:

<div style="text-align:center;"><math>\sum =\frac{1-{r}^{\left(n+1\right)}}{1-r}</math></div>

Where:* <div style="margin-left:0in;margin-right:0in;"><span style="background-color:transparent;">'''a1'''</span> is the first term of the progression.</div>
* <div style="margin-left:0in;margin-right:0in;"><span style="background-color:transparent;">'''r'''</span> is the common ratio between terms.</div>
* <div style="margin-left:0in;margin-right:0in;"><span style="background-color:transparent;">'''n'''</span> is the number of terms.</div>



For the geometric progression in the given example, the whole retry operation may backoff for up to 2.7 seconds.


=== {{anchor|RefHeadingToc16433947954761}} The crèam de la crèam: Exponential Backoff with Random Jitter ===

If you are using a shared resource, such as a network service, the problem known as “thundering herd problem” may arise. Imagine a scenario where a network problem cause connections to hang and multiple nodes are waiting. Suddenly, the problem is solved – meaning all hanged connections are dropped at the same time, while new ones may be accepted. If all the nodes are running the same code, whatever the backoff strategy used (from the ones we’ve seen so far) is likely to cause all the retry attempts to be done simultaneously, as all instances would be backing off for the exact same amount. This sudden surge in requests can overwhelm the resource, causing it to become unavailable or significantly slow down.

The term “thundering herd” is an analogy to a herd of animals rushing towards a water source. Just as a large herd of animals can congest the access to the water source, a large number of concurrent requests can overwhelm a resource and cause it to malfunction.

To mitigate this, we must go beyond predictable behaviors – and this is best done by progressing the backoff time exponentially with an added random jitter.

To use the jittered, exponential backoff:<div style="margin-left:0in;margin-right:0in;"><span style="color:#7a7e85;">/// </span><span style="color:#7a7e85;">backoff exponentially, from 100ms to 15 seconds in </span><span style="color:#7a7e85;">1</span><span style="color:#7a7e85;">0 re-attempts/// with +/- </span><span style="color:#7a7e85;">2</span><span style="color:#7a7e85;">0% random variance – </span><span style="color:#7a7e85;">ideal for retrying network requests</span><span style="color:#cf8e6d;">const </span><span style="color:#bcbec4;">EXPONENTIAL_JITTER_CONFIG: </span><span style="color:#bcbec4;">keen_retry::ExponentialJitter</span><span style="color:#cf8e6d;"> = </span><span style="color:#bcbec4;">keen_retry::ExponentialJitter::FromBackoffRange { backoff_range_millis: </span><span style="color:#2aacb8;">1</span><span style="color:#2aacb8;">00</span><span style="color:#bcbec4;">..=</span><span style="color:#2aacb8;"><tt>''15000''</tt></span><span style="color:#bcbec4;">, re_attempts: </span><span style="color:#2aacb8;"><tt>''1</span><span style="color:#2aacb8;">0''</tt></span><span style="color:#bcbec4;">, jitter_ratio: </span><span style="color:#2aacb8;"><tt>''0.</span><span style="color:#2aacb8;">2''</tt></span><span style="color:#bcbec4;">, };</span><span style="color:#cf8e6d;">let </span><span style="color:#bcbec4;">result = produce_operation_retry()</span><span style="color:#bcbec4;"> .retry_with</span><span style="color:#bcbec4;">(|_| produce_operation_retry())</span><span style="color:#7a7e85;"> </span><span style="color:#bcbec4;">'''.with_exponential_jitter'''</span><span style="color:#bcbec4;">(</span><span style="color:#bcbec4;">EXPONENTIAL_JITTER_CONFIG</span><span style="color:#bcbec4;">) .into();</span></div>{{anchor|RefHeadingToc16123947954761}} 

High available systems with low error rates may benefit from using an initial backoff of 0: if one of the nodes on a highly distributed system fail, retrying by waiting zero time may be the best approach (as failures are rare) – in this scenario, the request might be promptly picked by another node. Subsequent retries may wait progressively more, if this doesn’t hold true.

= {{anchor|RefHeadingToc15943947954761}} Important Staging Rust Features =

In the future, the <tt>keen-retry</tt> crate may benefit from the following features are are awaiting their turn to make it in stable Rust:

== {{anchor|RefHeadingToc19423947954761}} Async fn in Traits ==

Despite we can use <tt>Box<></tt> around a <tt>Future</tt> to simulate an “async” trait, as the <tt>sync-trait</tt> crate does, this rules out many code optimizations that could be done by the compiler – apart from requiring a <tt>malloc()</tt> on every method call. This is, currently, an unacceptable performance hit and the <tt>keen_retry_executors</tt> module does the next best thing: to repeat the method signatures, in order for both the sync and async executors to have the same API.

This is, obviously, not a great solution, as it impacts code maintainability, but, at least, it has no impacts in performance. Once the “Async fn in Traits” make it to stable Rust, that portion of the code can be improved. For more info, see [https://blog.rust-lang.org/inside-rust/2023/05/03/stabilizing-async-fn-in-trait.html Stabilizing async fn in traits in 2023].


== {{anchor|RefHeadingToc19443947954761}} The Try trait ==

Refactoring code that uses <tt>keen-retry</tt> enabled libraries is easy. As mentioned, our <tt>ResolvedResult</tt> may be very easily converted into a standard <tt>Result</tt> by calling <tt>.into()</tt> or <tt>.into_result()</tt>.

When stable Rust allows user types to implement the <tt>Try</tt> trait, that extra call won’t be needed, in most cases. The <tt>Try</tt> trait, if implemented, allows the compiler to work with the ? operator directly, so code like the following, in the application logic, could be rewritten from this:

<span style="color:#cf8e6d;">let</span><span style="color:#bcbec4;"> output = h</span><span style="color:#bcbec4;">andle</span><span style="color:#bcbec4;">.</span><span style="color:#bcbec4;">retryable_method</span><span style="color:#bcbec4;">().into()</span><span style="color:#cf8e6d;">?</span><span style="color:#bcbec4;"><nowiki>;</nowiki></span>

into this slightly simplified form:

<span style="color:#cf8e6d;">let</span><span style="color:#bcbec4;"> output = h</span><span style="color:#bcbec4;">andle</span><span style="color:#bcbec4;">.</span><span style="color:#bcbec4;">retryable_method</span><span style="color:#bcbec4;">()</span><span style="color:#cf8e6d;">?</span><span style="color:#bcbec4;"><nowiki>;</nowiki></span>

which is exactly the same as if <tt>retryable_method()</tt> returned a standard <tt>Result</tt> type.

Notice that, by now, the recommended Pattern for wrapping calls to retryable methods locally overcomes most of this trouble.

= Other Crates Similar to keen-retry =

= ... =

= {{anchor|RefHeadingToc16143947954761}} Index =

An index to quickly locate information within the booklet.



